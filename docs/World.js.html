<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>World.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-Bounds-Bounds.html">Bounds</a><ul class='methods'><li data-type='method'><a href="module-Bounds-Bounds.html#contains">contains</a></li><li data-type='method'><a href="module-Bounds-Bounds.html#draw">draw</a></li></ul></li><li><a href="module-Node-Node.html">Node</a><ul class='methods'><li data-type='method'><a href="module-Node-Node.html#draw">draw</a></li><li data-type='method'><a href="module-Node-Node.html#iterate">iterate</a></li></ul></li><li><a href="module-Path-Path.html">Path</a><ul class='methods'><li data-type='method'><a href="module-Path-Path.html#addNode">addNode</a></li><li data-type='method'><a href="module-Path-Path.html#addToHistory">addToHistory</a></li><li data-type='method'><a href="module-Path-Path.html#applyAlignment">applyAlignment</a></li><li data-type='method'><a href="module-Path-Path.html#applyAttraction">applyAttraction</a></li><li data-type='method'><a href="module-Path-Path.html#applyBounds">applyBounds</a></li><li data-type='method'><a href="module-Path-Path.html#applyBrownianMotion">applyBrownianMotion</a></li><li data-type='method'><a href="module-Path-Path.html#applyRepulsion">applyRepulsion</a></li><li data-type='method'><a href="module-Path-Path.html#draw">draw</a></li><li data-type='method'><a href="module-Path-Path.html#drawBounds">drawBounds</a></li><li data-type='method'><a href="module-Path-Path.html#drawCurrentEdges">drawCurrentEdges</a></li><li data-type='method'><a href="module-Path-Path.html#drawCurrentNodes">drawCurrentNodes</a></li><li data-type='method'><a href="module-Path-Path.html#drawEdges">drawEdges</a></li><li data-type='method'><a href="module-Path-Path.html#drawPreviousEdges">drawPreviousEdges</a></li><li data-type='method'><a href="module-Path-Path.html#getConnectedNodes">getConnectedNodes</a></li><li data-type='method'><a href="module-Path-Path.html#getInvertedColors">getInvertedColors</a></li><li data-type='method'><a href="module-Path-Path.html#getMidpointNode">getMidpointNode</a></li><li data-type='method'><a href="module-Path-Path.html#getTraceMode">getTraceMode</a></li><li data-type='method'><a href="module-Path-Path.html#injectNode">injectNode</a></li><li data-type='method'><a href="module-Path-Path.html#injectNodeByCurvature">injectNodeByCurvature</a></li><li data-type='method'><a href="module-Path-Path.html#injectRandomNode">injectRandomNode</a></li><li data-type='method'><a href="module-Path-Path.html#iterate">iterate</a></li><li data-type='method'><a href="module-Path-Path.html#moveTo">moveTo</a></li><li data-type='method'><a href="module-Path-Path.html#pruneNodes">pruneNodes</a></li><li data-type='method'><a href="module-Path-Path.html#scale">scale</a></li><li data-type='method'><a href="module-Path-Path.html#setBounds">setBounds</a></li><li data-type='method'><a href="module-Path-Path.html#setInvertedColors">setInvertedColors</a></li><li data-type='method'><a href="module-Path-Path.html#setMaxDistance">setMaxDistance</a></li><li data-type='method'><a href="module-Path-Path.html#setMinDistance">setMinDistance</a></li><li data-type='method'><a href="module-Path-Path.html#setRepulsionRadius">setRepulsionRadius</a></li><li data-type='method'><a href="module-Path-Path.html#setTraceMode">setTraceMode</a></li><li data-type='method'><a href="module-Path-Path.html#splitEdges">splitEdges</a></li><li data-type='method'><a href="module-Path-Path.html#toArray">toArray</a></li><li data-type='method'><a href="module-Path-Path.html#toggleInvertedColors">toggleInvertedColors</a></li><li data-type='method'><a href="module-Path-Path.html#toggleTraceMode">toggleTraceMode</a></li></ul></li><li><a href="module-SVGLoader-SVGLoader.html">SVGLoader</a><ul class='methods'><li data-type='method'><a href="module-SVGLoader-SVGLoader.html#.load">load</a></li><li data-type='method'><a href="module-SVGLoader-SVGLoader.html#.loadFromObject">loadFromObject</a></li></ul></li><li><a href="module-World-World.html">World</a><ul class='methods'><li data-type='method'><a href="module-World-World.html#addPath">addPath</a></li><li data-type='method'><a href="module-World-World.html#addPaths">addPaths</a></li><li data-type='method'><a href="module-World-World.html#addToHistory">addToHistory</a></li><li data-type='method'><a href="module-World-World.html#buildTree">buildTree</a></li><li data-type='method'><a href="module-World-World.html#clearPaths">clearPaths</a></li><li data-type='method'><a href="module-World-World.html#createPathElFromNodes">createPathElFromNodes</a></li><li data-type='method'><a href="module-World-World.html#draw">draw</a></li><li data-type='method'><a href="module-World-World.html#drawBackground">drawBackground</a></li><li data-type='method'><a href="module-World-World.html#export">export</a></li><li data-type='method'><a href="module-World-World.html#getDebugMode">getDebugMode</a></li><li data-type='method'><a href="module-World-World.html#getDrawBounds">getDrawBounds</a></li><li data-type='method'><a href="module-World-World.html#getDrawHistory">getDrawHistory</a></li><li data-type='method'><a href="module-World-World.html#getDrawNodes">getDrawNodes</a></li><li data-type='method'><a href="module-World-World.html#getFillMode">getFillMode</a></li><li data-type='method'><a href="module-World-World.html#iterate">iterate</a></li><li data-type='method'><a href="module-World-World.html#pause">pause</a></li><li data-type='method'><a href="module-World-World.html#prunePaths">prunePaths</a></li><li data-type='method'><a href="module-World-World.html#setAlignmentForce">setAlignmentForce</a></li><li data-type='method'><a href="module-World-World.html#setAttractionForce">setAttractionForce</a></li><li data-type='method'><a href="module-World-World.html#setDebugMode">setDebugMode</a></li><li data-type='method'><a href="module-World-World.html#setDrawBounds">setDrawBounds</a></li><li data-type='method'><a href="module-World-World.html#setDrawHistory">setDrawHistory</a></li><li data-type='method'><a href="module-World-World.html#setDrawNodes">setDrawNodes</a></li><li data-type='method'><a href="module-World-World.html#setFillMode">setFillMode</a></li><li data-type='method'><a href="module-World-World.html#setInvertedColors">setInvertedColors</a></li><li data-type='method'><a href="module-World-World.html#setMaxDistance">setMaxDistance</a></li><li data-type='method'><a href="module-World-World.html#setMinDistance">setMinDistance</a></li><li data-type='method'><a href="module-World-World.html#setRepulsionForce">setRepulsionForce</a></li><li data-type='method'><a href="module-World-World.html#setRepulsionRadius">setRepulsionRadius</a></li><li data-type='method'><a href="module-World-World.html#setTraceMode">setTraceMode</a></li><li data-type='method'><a href="module-World-World.html#toggleDebugMode">toggleDebugMode</a></li><li data-type='method'><a href="module-World-World.html#toggleDrawBounds">toggleDrawBounds</a></li><li data-type='method'><a href="module-World-World.html#toggleDrawHistory">toggleDrawHistory</a></li><li data-type='method'><a href="module-World-World.html#toggleDrawNodes">toggleDrawNodes</a></li><li data-type='method'><a href="module-World-World.html#toggleFillMode">toggleFillMode</a></li><li data-type='method'><a href="module-World-World.html#toggleInvertedColors">toggleInvertedColors</a></li><li data-type='method'><a href="module-World-World.html#togglePause">togglePause</a></li><li data-type='method'><a href="module-World-World.html#toggleTraceMode">toggleTraceMode</a></li><li data-type='method'><a href="module-World-World.html#unpause">unpause</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-Bounds.html">Bounds</a></li><li><a href="module-Defaults.html">Defaults</a></li><li><a href="module-Node.html">Node</a></li><li><a href="module-Path.html">Path</a></li><li><a href="module-SVGLoader.html">SVGLoader</a></li><li><a href="module-World.html">World</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">World.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module World */

let rbush = require('rbush'),
    toPath = require('svg-points/').toPath,
    saveAs = require('file-saver').saveAs,
    Defaults = require('./Defaults');

/** Manages a set of Paths and provides some global control mechanisms, such as pausing the simulation. */
class World {
  /**
   * Create a new World object
   * @param {object} p5 Reference to global p5.js instance
   * @param {object} [settings] Object containing local override Settings to be merged with Defaults
   * @param {array} [paths] Array of Path objects that belong to this World
   */
  constructor(p5, settings = Defaults, paths = []) {
    this.p5 = p5;
    this.paths = paths;

    this.paused = false;
    this.settings = Object.assign({}, Defaults, settings);

    this.traceMode = this.settings.TraceMode;
    this.drawNodes = this.settings.DrawNodes;
    this.debugMode = this.settings.DebugMode;
    this.invertedColors = this.settings.InvertedColors;
    this.fillMode = this.settings.FillMode;
    this.drawHistory = this.settings.DrawHistory;
    this.useBrownianMotion = this.settings.UseBrownianMotion;
    this.showBounds = this.settings.ShowBounds;

    this.tree = rbush(9, ['.x','.y','.x','.y']);  // use custom accessor strings per https://github.com/mourner/rbush#data-format
    this.buildTree();
    
    // Begin capturing path history
    let _this = this;
    setInterval(function() {
      _this.addToHistory(); 
    }, this.settings.HistoryCaptureInterval);
  }

  /** Run a single "tick" of the simulation by iterating on all Paths */
  iterate() {
    this.prunePaths();
    this.buildTree();

    if (this.paths != undefined &amp;&amp; this.paths instanceof Array &amp;&amp; this.paths.length > 0 &amp;&amp; !this.paused) {
      for (let path of this.paths) {
        path.iterate(this.tree);
      }
    }
  }

  /** Draw the background and all Paths */
  draw() {
    if (!this.traceMode) {
      this.drawBackground();
    }

    for (let path of this.paths) {
      path.draw();
    }
  }

  /** Draw the background to the canvas */
  drawBackground() {
    if(!this.invertedColors) {
      this.p5.background(255);
    } else {
      this.p5.background(0);
    }
  }

  /** Build an R-tree spatial index with all Nodes of all Paths in this World */
  buildTree() {
    this.tree.clear();
    
    for(let path of this.paths) {
      this.tree.load(path.nodes);
    }
  }

  /**
   * Add a new Path to the World from outside this class
   * @param {object} path Path object to add to this World
   */
  addPath(path) {
    // Cascade all current World settings to new path
    path.drawNodes = this.drawNodes;
    path.debugMode = this.debugMode;
    path.fillMode = this.fillMode;
    path.useBrownianMotion = this.useBrownianMotion;
    path.setInvertedColors(this.invertedColors);
    path.setTraceMode(this.traceMode);

    this.paths.push(path);
  }

  /**
   * Add multiple Path objects to this World
   * @param {array} paths 
   */
  addPaths(paths) {
    for(let path of paths) {
      this.addPath(path);
    }
  }

  /** Add another snapshot to each Path */
  addToHistory() {
    if(!this.paused) {
      for(let path of this.paths) {
        path.addToHistory();
      }
    }
  }

  /** Remove any Paths that have gotten too small */
  prunePaths() {
    for(let i = 0; i &lt; this.paths.length; i++) {
      if(this.paths[i].nodes.length &lt;= 1) {
        this.paths.splice(i, 1);
      }
    }
  }

  /** Generate an SVG file using the current canvas contents and open up a download prompt on the user's machine */
  export() {
    let svg = document.createElement('svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    svg.setAttribute('width', window.innerWidth);
    svg.setAttribute('height', window.innerHeight);
    svg.setAttribute('viewBox', '0 0 ' + window.innerWidth + ' ' + window.innerHeight);

    // Add a &lt;path> node for every Path in this World
    for(let path of this.paths) {

      // If history is enabled, create a new &lt;path> node for each snapshot
      if(this.drawHistory) {
        for(let nodes of path.nodeHistory) {
          svg.appendChild( this.createPathElFromNodes(nodes, path.isClosed) );
        }
      }

      svg.appendChild( this.createPathElFromNodes(path.nodes), path.isClosed );
    }

    // Force download of SVG based on https://jsfiddle.net/ch77e7yh/1
    let svgDocType = document.implementation.createDocumentType('svg', "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
    let svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
    svgDoc.replaceChild(svg, svgDoc.documentElement);
    let svgData = (new XMLSerializer()).serializeToString(svgDoc);

    let blob = new Blob([svgData.replace(/>&lt;/g, '>\n\r&lt;')]);
    saveAs(blob, 'differential-growth-' + Date.now() + '.svg');
  }

  /**
   * Create a new SVG path element from a provided set of Node objects
   * @param {array} nodes Array of Node objects
   * @param {boolean} isClosed Whether this path should be closed (true) or open (false)
   * @returns SVG path DOM node with a `d` attribute generated from the provided Nodes array.
   */
  createPathElFromNodes(nodes, isClosed) {
    let pointsString = '';

    for(let [index, node] of nodes.entries()) {
      pointsString += node.x + ',' + node.y;

      if(index &lt; nodes.length - 1) {
        pointsString += ' ';
      }
    }

    let d = toPath({
      type: 'polyline',
      points: pointsString
    });

    if(isClosed) {
      d += ' Z';
    }

    let pathEl = document.createElement('path');
    pathEl.setAttribute('d', d);
    pathEl.setAttribute('style', 'fill: none; stroke: black; stroke-width: 1');

    return pathEl;
  }

  /** Remove all Paths from this World */
  clearPaths() {
    this.paths = [];
  }

  /** Pause the simulation */
  pause() {
    this.paused = true;
  }

  /** Unpause the simulation */
  unpause() {
    this.paused = false;
  }

  /**
   * Get the current state of the Nodes visibility flag
   * @returns {boolean} Current state of Node visibility flag
   */
  getDrawNodes() {
    return this.drawNodes;
  }

  /**
   * Get the current state of the debug mode flag
   * @returns {boolean} Current state of debug mode flag
   */
  getDebugMode() {
    return this.debugMode;
  }

  /**
   * Get the current state of the fill mode flag
   * @returns {boolean} Current state of the fill mode flag
   */
  getFillMode() {
    return this.fillMode;
  }

  /**
   * Get the current state of the history effect visibility flag
   * @returns {boolean} Current state of the history effect visibility flag
   */
  getDrawHistory() {
    return this.drawHistory;
  }

  /**
   * Get the current state of the Bounds visibility flag
   * @returns {boolean} Current state of the Bounds visibility flag
   */
  getDrawBounds() {
    return this.showBounds;
  }

  /**
   * Set the minimum distance that each Node wants to be from it's connected neighbors
   * @param {number} minDistance Distance that each Node wants to be from it's neighbors
   */
  setMinDistance(minDistance) {
    this.settings.MinDistance = minDistance;

    for(let path of this.paths) {
      path.setMinDistance(minDistance);
    }
  }

  /**
   * Set the maximum distance an edge can be before it is split
   * @param {number} maxDistance Distance between each Node
   */
  setMaxDistance(maxDistance) {
    this.settings.MaxDistance = maxDistance;

    for(let path of this.paths) {
      path.setMaxDistance(maxDistance);
    }
  }

  /**
   * Set the distance around each Node that it can affect other Nodes through repulsion
   * @param {number} repulsionRadius Distance around each Node
   */
  setRepulsionRadius(repulsionRadius) {
    this.settings.RepulsionRadius = repulsionRadius;

    for(let path of this.paths) {
      path.setRepulsionRadius(repulsionRadius);
    }
  }

  /**
   * Set the force scalar that is used when Nodes pull each other closer
   * @param {number} attractionForce Scalar value used for attraction force
   */
  setAttractionForce(attractionForce) {
    this.settings.AttractionForce = attractionForce;

    for(let path of this.paths) {
      path.setAttractionForce(attractionForce);
    }
  }

  /**
   * Set the force scalar that is used when Nodes are pushing others away
   * @param {number} repulsionForce Scalar value used for repulsion force
   */
  setRepulsionForce(repulsionForce) {
    this.settings.RepulsionForce = repulsionForce;

    for(let path of this.paths) {
      path.setRepulsionForce(repulsionForce);
    }
  }

  /**
   * Set the force scalar that is used when Nodes trying to align with their neighbors to reduce curvature
   * @param {number} alignmentForce Scalar value used for alignment force
   */
  setAlignmentForce(alignmentForce) {
    this.settings.AlignmentForce = alignmentForce;

    for(let path of this.paths) {
      path.setAlignmentForce(alignmentForce);
    }
  }

  /**
   * Set the state of the Node visibility flag
   * @param {boolean} state Next state for the Node visibility flag
   */
  setDrawNodes(state) {
    this.drawBackground();

    for (let path of this.paths) {
      path.drawNodes = state;
      path.draw();
    }

    this.drawNodes = state;
    this.settings.DrawNodes = state;
  }

  /**
   * Set the state of the "debug mode" flag
   * @param {boolean} state Next state for the "debug mode" flag
   */
  setDebugMode(state) {
    this.drawBackground();

    for (let path of this.paths) {
      path.debugMode = state;
      path.draw();
    }

    this.debugMode = state;
    this.settings.DebugMode = state;
  }

  /**
   * Set the state of the "fill mode" flag
   * @param {boolean} state Next state for the "fill mode" flag
   */
  setFillMode(state) {
    this.drawBackground();

    for(let path of this.paths) {
      path.fillMode = state;
      path.draw();
    }

    this.fillMode = state;
    this.settings.FillMode = state;
  }

  /**
   * Set the state of the "history" effect flag
   * @param {boolean} state Next state for the "history" effect flag
   */
  setDrawHistory(state) {
    this.drawBackground();

    for(let path of this.paths) {
      path.drawHistory = state;
      path.draw();
    }

    this.drawHistory = state;
    this.settings.DrawHistory = state;
  }

  /**
   * Set the state of the "trace mode" flag
   * @param {boolean} state Next state for the "trace mode" flag
   */
  setTraceMode(state) {
    this.traceMode = state;
    this.settings.TraceMode = state;
    this.drawBackground();

    for(let path of this.paths) {
      path.traceMode = state;
    }
  }

  /**
   * Set the state of the "invert colors" flag
   * @param {boolean} state Next state for the "invert colors" flag
   */
  setInvertedColors(state) {
    this.invertedColors = state;
    this.settings.InvertedColors = state;
    this.drawBackground();

    for(let path of this.paths) {
      path.invertedColors = state;
    }
  }

  /**
   * Set the state of the Bounds visibility flag
   * @param {boolean} state Next state for the Bounds visibility flag
   */
  setDrawBounds(state) {
    this.drawBackground();

    for(let path of this.paths) {
      path.showBounds = state;
      path.draw();
    }

    this.showBounds = state;
  }

  /** Toggle the state of the Node visibility flag */
  toggleDrawNodes() {
    this.setDrawNodes(!this.getDrawNodes());
  }

  /** Toggle the state of the "trace mode" effect flag */
  toggleTraceMode() {
    this.traceMode = !this.traceMode;
    this.drawBackground();

    for(let path of this.paths) {
      path.toggleTraceMode();
      path.draw();
    }
  }

  /** Toggle the state of the "invert colors" flag */
  toggleInvertedColors() {
    this.invertedColors = !this.invertedColors;

    this.drawBackground();

    for(let path of this.paths) {
      path.toggleInvertedColors();
      path.draw();
    }
  }

  /** Toggle the state of the "debug mode" flag */
  toggleDebugMode() {
    this.setDebugMode(!this.getDebugMode());
  }

  /** Toggle the state of the "fill mode" flag */
  toggleFillMode() {
    this.setFillMode(!this.getFillMode());
  }

  /** Toggle the state of the "history" effect flag */
  toggleDrawHistory() {
    this.setDrawHistory(!this.getDrawHistory());
  }

  /** Toggle the state of the Bounds visibility flag */
  toggleDrawBounds() {
    this.setDrawBounds(!this.getDrawBounds());
  }

  /** Toggle the pause/unpause state of the simulation */
  togglePause() {
    if(this.paused) {
      this.unpause();
    } else {
      this.pause();
    }
  }
}

module.exports = World;</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Jan 12 2019 23:25:46 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
